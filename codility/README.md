### BimaryGap
```
* bit의 개념을 알고있는지를 물어보는 문제
첫 1이 등장하는 것도 처리해 주어야 한다. 10000 = 16 의 정답은 0 이다. 
```

### CyclicRotation
```
* 배열을 회전시킬 수 있는지, 배열의 동작 
나는 deque 자료구조를 이용하여 해결  배열이 비어있는 경우 예외 처리 했다.
```

### Odd ~~
```
* 짝이 없는 한 홀수를 구하는 문제 
짝이있는 경우 2번씩 등장하므로 exclusive를 활용하여 모두 구하면 짝이없는
하나의 수가 남는다.
*  ex) 9 = 1001  0000 ^= 1001 => 1001   한번 더등장하면 1001 ^= 1001 => 0000 으로 돌아오니까
마지막에 남는건 한번 등장한 수이다.
```

### FrogJmp
```
* x에 d를 더하는 방법으로는 시간초과가 걸린다. y-x차이가 크고 d가 작을 경우가 있기 때문에 
* y-x 가 d로 나눠질 경우 ret , 안나눠질 경우 ret +1로 정답을 구할 수 있다.
```

### PermMissingElem
```
* 최대 100000 의 수가 들어오니까 check 배열에 표시하고
1부터 n+1 까지의 check를 검사해 없으면 리턴했다.
```

### TapeEquilibrium
```
* 배열의 모든 합을 미리 구하고 앞에서 부터 더해가면서 가장 최소의 값이 나오도록 했다. 구간이기 때문에 마지막 구간은 포함시키지 않아야 한다. 마지막 구간을 포함시키면 part_b부분이 없기 때문이다.
```

### FrogRiverOne
```
* 도달위치와 그 전까지 위치 모두 잎이 있을 때 가장 작은 시간을 구하는 문제인데, 먼저 위치와 시간 순으로 정렬을 하고 가장 작은 시간을 구해가면서 마지막 위치까지 잎이 있는지 확인하였다.

* 정렬했기 때문에 다음 위치에 잎이 없으면 절대 건널 수 없고 모든 배열을 돌았을 때 도착위치가 아닌 것은 마지막 잎이 없는 경우이다.
```

### MaxCounters
```
* 모두 max값으로 초기화를 할 때 시간복잡도가 신경 쓰여 어떻게 하지 생각했는데 계속 77점이 나왔다. 첫번째로 map을 이용해 clear시키고 다시 0 부터 더해가며 마지막에 max값을 더하는 방법을 이용했다.
* 두번째는 구글에 검색해서 알아보았는데 초기화 시킬 필요 없이
max값보다 작으면 max+1로 같거나 크면 ++ 하는식으로 훨씬 쉽게 해결 가능했다.
```

### MissingInteger
```
* 최대 1000000 까지 수가 들어오고 배열의 크기는 100000 이다. 꽉 채워도 100001이 정답이기 때문에 단순구현으로 해결했다.
```

###  PermCheck
```
* A의 크기보다 큰 수가 들어오면 무시하고 남은 수를 CHECK 해서 
1부터 A의 크기까지 모두 들어왔는지 확인하는 문제
```

###  CountDiv
```
* b를 k로 나눈 몫에서 a를 k로 나눈 몫을 빼서 중복을 제거하면 되겠다 했는데. 일단 0도 모든 수가 나누었을 때 나머지가 0이므로 추가한다. 또 a 가 아니라 a -1 까지를 확인했다. 중복 때문에
```

###  GenomicRangeQuery
```
* 문자열 순서에 맞게 ACGT의 개수를 저장하는 struct를 만들었고
쿼리에 따라 두 배열을 빼서 대표값을 찾게했다.
```

### MinAvgTwoSlice
```
* 아직도 잘 이해가 안간다. 풀이를 보았는데 결국 인덱스2개 ,3개 를 보는것이 정답안에 있고 4개이상은 볼 필요가 없다고 한다.ㅜㅜ 뭔말일까.
```

### PassingCars
```
* a와 b로 두 그룹으로 나누어 upperbound를 이용해 개수를 구하였다.
이렇게 하면 n log n 안에 답을 구할 수 있었다.
```

### Distinct
```
* -1000000 ~ 1000000 까지 들어올 수 있어서 배열 2000000 까지를 체크하는 방법으로 풀이했다.
```

###  MaxProductOfThree
```
음수의 경우가 복잡하게 느껴져서 5개 이하인 경우에는 모든 경우를 보았고 5개 이상인 경우 앞 3개 뒤 3개를 모두 비교해서 가장 큰 값을 리턴했다.
```

### NumberOfDiscIntersections
```
다른 풀이 소스를 보았는데 진짜 무슨말인지 몰라서 좌절하다가
o (n^2) 을 잘 잡아주면 해결할 수 있다고 해서 풀었다.
```

### Triangle
```
3개를 골라야하면 시간초과가 나서 어떤 규칙이 있나 보니까
정렬을 했을 때 세번째 값보다 첫번째와 두번째 값의 합보다 작으면 만족한다. 나머지 두조건은 확실하게 만족하기 때문이다.
따라서 A[i] A[i+1] > A[i+2] 으로 o(N) 만에 해결했다.
```

### Brackets
```
스택을 이용해서 {} [] () 쌍이 만나는 순간 빼주고 아닌경우 추가하는식으로 해결할 수 있다.
```

### Fish
```
stack을 이용해서 푸는 문제인데 구현에 신경 써야한다.
만약 1 1 1 0 이 나오면 거꾸로 올라가면서 탐색할 수 있도록 해야한다. stack은 아이디어는 쉽지만 놓치기 쉬운 부분이 많다.
```

###  Nesting
```
Brackets보다 한단계 쉬운 문제 stack을 이용해 해결한다.
```