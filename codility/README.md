### BimaryGap

* bit의 개념을 알고있는지를 물어보는 문제
첫 1이 등장하는 것도 처리해 주어야 한다. 10000 = 16 의 정답은 0 이다. 
-----------

### CyclicRotation

* 배열을 회전시킬 수 있는지, 배열의 동작 
나는 deque 자료구조를 이용하여 해결  배열이 비어있는 경우 예외 처리 했다.
-----------

### Odd ~~

* 짝이 없는 한 홀수를 구하는 문제 
짝이있는 경우 2번씩 등장하므로 exclusive를 활용하여 모두 구하면 짝이없는
하나의 수가 남는다.

*  ex) 9 = 1001  0000 ^= 1001 => 1001   한번 더등장하면 1001 ^= 1001 => 0000 으로 돌아오니까
마지막에 남는건 한번 등장한 수이다.
----------

### FrogJmp

* x에 d를 더하는 방법으로는 시간초과가 걸린다. y-x차이가 크고 d가 작을 경우가 있기 때문에 

* y-x 가 d로 나눠질 경우 ret , 안나눠질 경우 ret +1로 정답을 구할 수 있다.
------------

### PermMissingElem

* 최대 100000 의 수가 들어오니까 check 배열에 표시하고
1부터 n+1 까지의 check를 검사해 없으면 리턴했다.
------------

### TapeEquilibrium

* 배열의 모든 합을 미리 구하고 앞에서 부터 더해가면서 가장 최소의 값이 나오도록 했다. 구간이기 때문에 마지막 구간은 포함시키지 않아야 한다. 마지막 구간을 포함시키면 part_b부분이 없기 때문이다.
-----------

###  FrogRiverOne

* 도달위치와 그 전까지 위치 모두 잎이 있을 때 가장 작은 시간을 구하는 문제인데, 먼저 위치와 시간 순으로 정렬을 하고 가장 작은 시간을 구해가면서 마지막 위치까지 잎이 있는지 확인하였다.

정렬했기 때문에 다음 위치에 잎이 없으면 절대 건널 수 없고 모든 배열을 돌았을 때 도착위치가 아닌 것은 마지막 잎이 없는 경우이다.
