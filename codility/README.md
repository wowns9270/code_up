### BimaryGap

```
* bit의 개념을 알고있는지를 물어보는 문제
첫 1이 등장하는 것도 처리해 주어야 한다. 10000 = 16 의 정답은 0 이다.
```

### CyclicRotation

```
* 배열을 회전시킬 수 있는지, 배열의 동작
나는 deque 자료구조를 이용하여 해결  배열이 비어있는 경우 예외 처리 했다.
```

### Odd ~~

```
* 짝이 없는 한 홀수를 구하는 문제
짝이있는 경우 2번씩 등장하므로 exclusive를 활용하여 모두 구하면 짝이없는
하나의 수가 남는다.
*  ex) 9 = 1001  0000 ^= 1001 => 1001   한번 더등장하면 1001 ^= 1001 => 0000 으로 돌아오니까
마지막에 남는건 한번 등장한 수이다.
```

### FrogJmp

```
* x에 d를 더하는 방법으로는 시간초과가 걸린다. y-x차이가 크고 d가 작을 경우가 있기 때문에
* y-x 가 d로 나눠질 경우 ret , 안나눠질 경우 ret +1로 정답을 구할 수 있다.
```

### PermMissingElem

```
* 최대 100000 의 수가 들어오니까 check 배열에 표시하고
1부터 n+1 까지의 check를 검사해 없으면 리턴했다.
```

### TapeEquilibrium

```
* 배열의 모든 합을 미리 구하고 앞에서 부터 더해가면서 가장 최소의 값이 나오도록 했다. 구간이기 때문에 마지막 구간은 포함시키지 않아야 한다. 마지막 구간을 포함시키면 part_b부분이 없기 때문이다.
```

### FrogRiverOne

```
* 도달위치와 그 전까지 위치 모두 잎이 있을 때 가장 작은 시간을 구하는 문제인데, 먼저 위치와 시간 순으로 정렬을 하고 가장 작은 시간을 구해가면서 마지막 위치까지 잎이 있는지 확인하였다.

* 정렬했기 때문에 다음 위치에 잎이 없으면 절대 건널 수 없고 모든 배열을 돌았을 때 도착위치가 아닌 것은 마지막 잎이 없는 경우이다.
```

### MaxCounters

```
* 모두 max값으로 초기화를 할 때 시간복잡도가 신경 쓰여 어떻게 하지 생각했는데 계속 77점이 나왔다. 첫번째로 map을 이용해 clear시키고 다시 0 부터 더해가며 마지막에 max값을 더하는 방법을 이용했다.
* 두번째는 구글에 검색해서 알아보았는데 초기화 시킬 필요 없이
max값보다 작으면 max+1로 같거나 크면 ++ 하는식으로 훨씬 쉽게 해결 가능했다.
```

### MissingInteger

```
* 최대 1000000 까지 수가 들어오고 배열의 크기는 100000 이다. 꽉 채워도 100001이 정답이기 때문에 단순구현으로 해결했다.
```

### PermCheck

```
* A의 크기보다 큰 수가 들어오면 무시하고 남은 수를 CHECK 해서
1부터 A의 크기까지 모두 들어왔는지 확인하는 문제
```

### CountDiv

```
* b를 k로 나눈 몫에서 a를 k로 나눈 몫을 빼서 중복을 제거하면 되겠다 했는데. 일단 0도 모든 수가 나누었을 때 나머지가 0이므로 추가한다. 또 a 가 아니라 a -1 까지를 확인했다. 중복 때문에
```

### GenomicRangeQuery

```
* 문자열 순서에 맞게 ACGT의 개수를 저장하는 struct를 만들었고
쿼리에 따라 두 배열을 빼서 대표값을 찾게했다.
```

### MinAvgTwoSlice

```
* 아직도 잘 이해가 안간다. 풀이를 보았는데 결국 인덱스2개 ,3개 를 보는것이 정답안에 있고 4개이상은 볼 필요가 없다고 한다.ㅜㅜ 뭔말일까.
```

### PassingCars

```
* a와 b로 두 그룹으로 나누어 upperbound를 이용해 개수를 구하였다.
이렇게 하면 n log n 안에 답을 구할 수 있었다.
```

### Distinct

```
* -1000000 ~ 1000000 까지 들어올 수 있어서 배열 2000000 까지를 체크하는 방법으로 풀이했다.
```

### MaxProductOfThree

```
음수의 경우가 복잡하게 느껴져서 5개 이하인 경우에는 모든 경우를 보았고 5개 이상인 경우 앞 3개 뒤 3개를 모두 비교해서 가장 큰 값을 리턴했다.
```

### NumberOfDiscIntersections

```
다른 풀이 소스를 보았는데 진짜 무슨말인지 몰라서 좌절하다가
o (n^2) 을 잘 잡아주면 해결할 수 있다고 해서 풀었다.
```

### Triangle

```
3개를 골라야하면 시간초과가 나서 어떤 규칙이 있나 보니까
정렬을 했을 때 세번째 값보다 첫번째와 두번째 값의 합보다 작으면 만족한다. 나머지 두조건은 확실하게 만족하기 때문이다.
따라서 A[i] A[i+1] > A[i+2] 으로 o(N) 만에 해결했다.
```

### Brackets

```
스택을 이용해서 {} [] () 쌍이 만나는 순간 빼주고 아닌경우 추가하는식으로 해결할 수 있다.
```

### Fish

```
stack을 이용해서 푸는 문제인데 구현에 신경 써야한다.
만약 1 1 1 0 이 나오면 거꾸로 올라가면서 탐색할 수 있도록 해야한다. stack은 아이디어는 쉽지만 놓치기 쉬운 부분이 많다.
```

### Nesting

```
Brackets보다 한단계 쉬운 문제 stack을 이용해 해결한다.
```

### StoneWall

```
히스토그램이 생각나는 문제 이전의 높이보다 크면 스택에 추가해주고
같으면 추가하지 않고 작은 높이가 나오면 그 높이보다 작은 모든 st의 요소를 빼주면서 블록을 세주는 방식이다.
```

### Dominator

```
수의 범위가 넓어서 배열에 수를 저장하는 것으로는 메모리도 시간도 부족하다 map을 이용해서 개수를 구하고 순회하면서 가장 큰 수를 찾고
그 숫자가 등장하는 첫 인덱스를 리턴했다.
```

### EquiLeader

```
양쪽으로 나누어서 과반수 이상의 수가 같은가를 보는데 이게 성립하려면 결국 배열에서 가장 많이 등장한 수가 후보가된다. 그래서 map을 통해 가장 많이 등장한 수를 찾고 0~ 그 후보수가 나올 때마다 증가시키고 전체 후보수 - 지금까지 등장한 수 그리고 범위의 과반수 이상인지 구해주면된다.
```

### MaxDoubleSliceSum x

```

```

### MaxProfit

```
두개를 고르면 시간복잡도가 안될거같아서 다시 생각해보니 Q는 이전의 모든 인덱스가 후보이고 그러면 앞에서부터 자기자신을 포함한 가장 작은수를 담는 배열을 만들어
가장 작은 값과 Q를 비교해서 가장 이득이 높은것이 정답이라고 생각했다. 시간은 물론 O(n)

풀이를 찾아보니 Kadane's Algorithm 이라고 한다.
```

### CountFactors

```
최대공약수를 되게 오랜만에 구하게 됬는데 sqrt를 이용해서 구했다. 100000000
1억을 구하는데 o(1000) 정도라고 생각하면 100억을 구하는데 O(만) 정도라 나쁘지 않을 것 같다.
```

### Flags

```
성능 부분에서 86점이 자꾸 떠서 문제가 없다고 생각했는데 , 봉우리를 구할 때 A.size() -1 까지 해야하는데 그부분을 A.size() 라고 해서 고쳐서 제출하니까 정답처리 되었다.
```

### MinPerimterRectangle

```
최대값 실수로 고쳐서 정답 약수를 구하는 방법에 더 좋은 방법이 있는지 알아보아야 할 것 같다.
```

### Peaks

```
봉우리가 각 구간에 들어가는지 확인하는 작업을 효율적으로 코드를 짜기 힘들었는데
이런방식이 아름다웠다.
```

![image](https://user-images.githubusercontent.com/46587806/107214971-09d6d680-6a4e-11eb-8c4c-82e8334cbc5c.png)

### CountNonDivisible

```
처음에는 문제가 잘 이해되지 않았는데.. 결국 A[i] 라는 수는 그 약수를 제외한 나머지 수들의 개수를 구하는 문제이다. 이러면 이제 각 A[i]의 약수들의 개수를 알아야 해서 먼저 전체 cnt 배열에 각 수들의 개수를 넣고 합을 구해 전체 A의 사이즈에서 구한 개수를 뺐다.
```

### CountSemiprimes

```
먼저 소수인수를 에라토스테네스를 통해 걸러낸 후 소수를 제외한 수들중 1과 자기자신을 제외한 약수가 모두 소수로 이루어진 수를 semiprime에 저장한다. 그리고 쿼리를 빠르게 구하기위해 부분합을 이용해 해결했다.
```

### ChocolatesByNumbers

```
이문제가 왜 최대공약수의 배수가 답인지 아직 모르겠다. 솔루션을 알고 코드를 짜는 것은 쉬우나. 그 원리를 이해하기 어렵다. 제일어렵네 이문제..
```

### CommonPrimeDivisors x

```
최대공약수 문제인데 위 문제와 마찬가지로 모르겠다.
```

### FibFrog

```
문제를 이해하는데 시간이 오래걸렸다. 1이 있는 칸에서 원하는 피보나치 수만큼 뛰는것을 반복해서 도착지에 가장 적은 시도를 찾는 문제이다. -1 칸에서 뛸 수 있는 것들을 모두 뛰어보는 bfs를 이용하여 해결하였다.
```
