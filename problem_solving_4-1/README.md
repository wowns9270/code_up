:apple: 문제해결기법 4-1

### p100

```
단순하게 구현하면 정답이지만, 시간복잡도가 나올지 몰라 이런저런 방법을 생각하면서 고민을 오랬동안 했다. i , j 가 1000000까지인데 구하는 과정을 상수 시간으로 생각해야 할까?
```

### p10137

```
결국 돈을 많이 낸 사람이 얼마나 적게 돈을 뱉어 내야 하는가? 인데 총합을 나누었을 때 몫은 그 내야하는 돈의 평균이고 나머지는 1센트씩 더 내야하는 인원이 된다.

예를 들면, 1508원이 총 합이고 인원이 5명이면 2명은 301원을내고 3명은 302원을 낸다.(편의를 위해 값의 * 100을 했습니다.)

돈의 이동을 적게 하기 위해서 인원의 배열을 정렬해주고
301  301   302    302    302
a <   b  <  c   <  d   <  e

각인원의 값이 자기가 내야할 돈보다 많으면 그값을 뺀값을 모두 더하여 /100 을 해주면 된다.

```

### p679

```
노드의 false 인경우 왼쪽으로 내려가고 true면 오른쪽으로 내려간다. 내려갈 때 노드를 토글시켜주고 마지막 번째 리프를 출력하면된다.

리프를 구할 때에는 1 <<(n-1) 보다 같거나 크면 함수를 종료한다.
그래프를 이용한 단순 구현이다.
```

### p10010

```
말하는대로 8가지 방향을 모두 탐색하는 브르투포스 문제였다. 알파벳의 대문자와 소문자를 구분하지 않는 처리가 필요하다. 구현력이 중요한 문제.
```

### p10469

```
XOR 연산은 비트의 상태가 같을 때 0 다를 때 1로 반환한다 이를통해 4 ^ 6 = 2 라는 값을 얻을 수 있다.
```

### p10150

```
처음에 가능한 세트중에 가장 짧은 세트를 선택하는 식으로 했는데 30점의 시간초과가 나서 차이가 1인 각 단어들을 bfs 탐색을 통해 pre라는 이전 인덱스를 저장하고 reverse-search를 통해 찾고 reverse하는 방법으로 해결하였다.

이 풀이가 자명한 이유는 도착하는 단어에 들어간 pre라는 값은 가장 빠르게 도달했기 때문에 가장 짧은 단어 리스트를 구성할 수 밖에 없다.
```
