:apple: 문제해결기법 4-1

### p100

```
단순하게 구현하면 정답이지만, 시간복잡도가 나올지 몰라 이런저런 방법을 생각하면서 고민을 오랬동안 했다. i , j 가 1000000까지인데 구하는 과정을 상수 시간으로 생각해야 할까?
```

### p10137

```
결국 돈을 많이 낸 사람이 얼마나 적게 돈을 뱉어 내야 하는가? 인데 총합을 나누었을 때 몫은 그 내야하는 돈의 평균이고 나머지는 1센트씩 더 내야하는 인원이 된다.

예를 들면, 1508원이 총 합이고 인원이 5명이면 2명은 301원을내고 3명은 302원을 낸다.(편의를 위해 값의 * 100을 했습니다.)

돈의 이동을 적게 하기 위해서 인원의 배열을 정렬해주고
301  301   302    302    302
a <   b  <  c   <  d   <  e

각인원의 값이 자기가 내야할 돈보다 많으면 그값을 뺀값을 모두 더하여 /100 을 해주면 된다.

```

### p679

```
노드의 false 인경우 왼쪽으로 내려가고 true면 오른쪽으로 내려간다. 내려갈 때 노드를 토글시켜주고 마지막 번째 리프를 출력하면된다.

리프를 구할 때에는 1 <<(n-1) 보다 같거나 크면 함수를 종료한다.
그래프를 이용한 단순 구현이다.
```

### p10010

```
말하는대로 8가지 방향을 모두 탐색하는 브르투포스 문제였다. 알파벳의 대문자와 소문자를 구분하지 않는 처리가 필요하다. 구현력이 중요한 문제.
```

### p10469

```
XOR 연산은 비트의 상태가 같을 때 0 다를 때 1로 반환한다 이를통해 4 ^ 6 = 2 라는 값을 얻을 수 있다.
```

### p10150

```
처음에 가능한 세트중에 가장 짧은 세트를 선택하는 식으로 했는데 30점의 시간초과가 나서 차이가 1인 각 단어들을 bfs 탐색을 통해 pre라는 이전 인덱스를 저장하고 reverse-search를 통해 찾고 reverse하는 방법으로 해결하였다.

이 풀이가 자명한 이유는 도착하는 단어에 들어간 pre라는 값은 가장 빠르게 도달했기 때문에 가장 짧은 단어 리스트를 구성할 수 밖에 없다.
```

### p384

```
재귀를 이용한 문자열 검색 문제이다. slimp와 slump를 각각의 규칙에 맞게 탐색하고 slimp + slump 가 만족하는지 구현하면된다.
```

### snail

```
개미가 올라갈 수 있는지 없는 지 알아보는 문제인데 이런 문제는 "변수를 어떻게 설정할 것인가" 가 중요한 것 같다.

초과 미만의 조건을 잘보고 또 등반 높이가 - 가되는 것부터 0으로 바뀐다라는 것을 아는 것이 중요하다.
``
```

### rbt

```
레드 블랙 트리 구현 리프노드를 꼭 넣길 바래요.  그리고 삭제는 손으로 먼저 해보는 것을 추천드려요.
다시는 하고 싶지 않아요.
```

### point

```
ccw를 잘 사용하면 쉽게 풀 수 있다.
1. 점이 다각형을 이루는 선에 포함된는 것을 우선 찾는다.
2. 다각형에 접하지 않다면 외부 , 내부 둘중에 하나이다.
3. 모든 선에 대하여 p의 오른쪽 수평선과 아래쪽에서만나는 지 확인하기 위해 y좌표와 ccw로 찾아낸다.
4. 여기서 ccw는 p에대하여 선이 왼쪽인지 오른쪽인지 구별하는데 사용된다.
```
