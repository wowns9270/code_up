#include<bits/stdc++.h>
using namespace std;

int n, m;
long long arr[200000];

//이분탐색은 정말 구조를 알아도 이해하기는 어려운게 있다.
//우리는 던지는 값으로 가장인접한 공유기 사이의 거리를 던진다.
//그럼 최소는 1이고 최대는 주어진 집 사이의 거리가 가장 큰값의 차이가 된다.
//그럼 중간값으로 던져보자 1 2 8 4 9 가 주어지면 정렬을 통해
// 집 위치는 1 2 4 8 9 이렇게 되고 
// mid는 1+8 /2 4이다.. 4로 던진다는 말은 공유기 사이의 최솟값이 4라는 예기다.
//그럼 처음 부터 1번에 놓고 2번은 거리가 1밖에 안되니까 놓지 않는다.
//4는 거리가 3이다 그러면 최솟값을 4라고 정했는데 3밖에 안되니까 공유기를 놓을 수
//없다. 그다음 8 8에는 공유기를 설치할 수 있다. 공유기의 최소 거리보다 크기 때문에
//가능하다 8 에 놓고 9 는 당연히 불가능하다. 그럼 우리는 공유기를 1 과 8 두 군데에
//놓았다(8대신 9에 놓아도 상관없다) 그러면 우리가 공유기를 3개를 설치 해야하는데
//공유기 사이의 거리가 길어서 2개밖에 놓지 못하였다. 이말은 가장 인접한 두 공유기 사이
//의 거리가 4라면 공유기를 2개밖에 못놓는다는거다 그래서 우리는
//다시 던질값을 찾는다 이번에는 1+3 /2 이다 즉 2다 
//처음부터 1에놓고 2는 못놓고 4에 놓고 8에 놓으면 어! 공유기를 3개를 놨다.
//여기서 끝이 아니다 우리는 어떤값을 던졌을 때 가장 최대가 되는지 궁금하다
//lo = mid +1 을하면 3 3 이다 그러면 또 돈다 그럼 4 3 이되어 lo가 hi보다
//커지게 되고 그때 hi값이 결국 공유기 3개를 놨을때 가장 인접한 거리가 되겠다.

//사실 이렇게 이해 하는게 맞는지 모르겠다.
int main() {
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> arr[i];
	sort(arr, arr + n);
	long long lo = 1;
	long long hi = arr[n - 1] - arr[0];
	while (lo <= hi) {
		long long mid = (lo + hi) / 2;
		int cnt = 1;
		int idx = arr[0];
		for (int i = 0; i < n; i++) {
			if (arr[i] - idx >= mid) {
				cnt++;
				idx = arr[i];
			}
		}

		if (cnt >= m) lo = mid + 1;
		else hi = mid - 1;
	}
	cout << hi;
	return 0;

}